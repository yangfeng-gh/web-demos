{"version":3,"sources":["y修饰符.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;;;AAGA;AACA;AACA;AACA;AACA,MAAM,4BAAN;AACA;AACA,QAAM,SAAN,GAAkB,CAAlB;AACA;AACA,QAAM,IAAN,CAAW,MAAX,E,CAAmB;AACnB;AACA,QAAM,SAAN,GAAkB,CAAlB;AACA;AACA,MAAI,QAAQ,MAAM,IAAN,CAAW,MAAX,CAAZ;AACA,UAAQ,MAAM,IAAN,CAAW,MAAX,CAAR;AACA,UAAQ,GAAR,CAAY,MAAM,KAAlB;AACA,UAAQ,GAAR,CAAY,MAAM,SAAlB;;AAEA","file":"y修饰符.js","sourcesContent":["/**\r\n * y修饰符\r\n */\r\n// 单单一个y修饰符对replace方法只能匹配一次\r\n// y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。\r\n// 不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，\r\n// 这也就是“粘连”的涵义。\r\nconst REGEX = /a/y;\r\n// 指定从2号位置开始匹配\r\nREGEX.lastIndex = 2;\r\n// 不是粘连，匹配失败\r\nREGEX.exec('xaya') // null\r\n// 指定从3号位置开始匹配\r\nREGEX.lastIndex = 3;\r\n// 3号位置是粘连，匹配成功\r\nlet match = REGEX.exec('xaxa');\r\nmatch = REGEX.exec('xaxa');\r\nconsole.log(match.index);\r\nconsole.log(match.lastIndex);\r\n\r\n/*const REGEX = /a/y;\r\nlet r = 'aaxa'.replace(REGEX, '-')\r\nconsole.log(r);// '-axa'\r\n\r\nconst REGEX = /a/gy;\r\nlet r = 'aaxa'.replace(REGEX, '-')\r\nconsole.log(r);// '--xa'*/\r\n\r\n"]}