{"version":3,"sources":["codePointAt.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAGA,QAAI,IAAI,KAAR;;AAEA,QAAI,MAAM,EAAE,MAAZ,C,CAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,aAAS,OAAT,CAAiB,CAAjB,EAAoB;AAChB,eAAO,EAAE,WAAF,CAAc,CAAd,IAAmB,MAA1B;AACH;;AAED,YAAQ,GAAR,CAAY,QAAQ,IAAR,CAAZ,E,CAA4B;AAC5B,YAAQ,GAAR,CAAY,QAAQ,GAAR,CAAZ,E,CAA2B;;AAE3B;AACA;AACA;;AAEA,QAAI,IAAI,KAAR;;;;;;AACA,wDAAe,CAAf,4GAAkB;AAAA,gBAAT,EAAS;;AACd,oBAAQ,GAAR,CAAY,GAAG,WAAH,CAAe,CAAf,EAAkB,QAAlB,CAA2B,EAA3B,CAAZ;AACH","file":"codePointAt.js","sourcesContent":["/**\r\n * Created by yvan on 2016-06-30.\r\n */\r\nvar s = \"𠮷a\";\r\n\r\nvar len = s.length; // 2\r\n// console.log(len);\r\n// console.log(s.charAt(0)); // �\r\n// console.log(s.charAt(1)); // �\r\n// console.log(s.charCodeAt(0)); // 55362\r\n// console.log(s.charCodeAt(1)); // 57271\r\n//\r\n// console.log(s.codePointAt(0)); //134071\r\n// console.log('\\u{20BB7}');\r\n// console.log(s.codePointAt(1)); //\r\n// console.log(s.charCodeAt(2)); // 97\r\n\r\n\r\nfunction is32Bit(c) {\r\n    return c.codePointAt(0) > 0xFFFF;\r\n}\r\n\r\nconsole.log(is32Bit(\"𠮷\")); // true\r\nconsole.log(is32Bit(\"a\")); // false\r\n\r\n// 你可能注意到了，codePointAt方法的参数，仍然是不正确的。\r\n// 比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向charCodeAt方法传入2。\r\n// 解决这个问题的一个办法是使用for...of循环，因为它会正确识别32位的UTF-16字符。\r\n\r\nvar s = '𠮷a';\r\nfor (let ch of s) {\r\n    console.log(ch.codePointAt(0).toString(16));\r\n}"]}