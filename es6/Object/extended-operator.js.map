{"version":3,"sources":["extended-operator.es6"],"names":[],"mappings":"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","file":"extended-operator.js","sourcesContent":["'use strict';\r\n// 对象中的扩展运算符\r\n\r\n/**\r\n * 解构赋值\r\n *\r\n *\r\n *\r\n * 3.解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，\r\n * 而不是这个值的副本;\r\n * 4.扩展运算符修饰的变量解构赋值不会拷贝继承自原型对象的属性;\r\n */\r\n\r\n/**\r\n * 对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。\r\n * 所有的键和它们的值，都会拷贝到新对象上面。\r\n */\r\n{\r\n  const [a, ...b] = [1, 2, 3];\r\n  console.log('解析赋值拷贝键值：a = %d, b = %s', a, b)\r\n}\r\n\r\n{\r\n  let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4};\r\n  console.log(`解析赋值拷贝键值： ${JSON.stringify(z)}`);\r\n}\r\n\r\n/**\r\n * 1.解构赋值要求等号右边是一个对象,如果等号右边是null,undefined就会报错;\r\n */\r\n// let { x, y, ...z } = null; // 运行时错误\r\n// let { x, y, ...z } = undefined; // 运行时错误\r\n/**\r\n * 2.扩展运算符修饰的变量必须是最后一个参数，否则会报错;\r\n */\r\n// let { x, ...y, ...z } = obj; // 句法错误\r\n// let { ...x, y, z } = obj; // 句法错误\r\n\r\n/**\r\n * 解构赋值的拷贝是浅拷贝，\r\n * 即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\r\n */\r\n{\r\n  let obj = {a: {b: 1}};\r\n  let {...n} = obj;\r\n  obj.a.b = 2;\r\n  console.log(`解构赋值的拷贝是浅拷贝: ${n.a.b}`) // 2\r\n}\r\n// 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。\r\n\r\n{\r\n  let o = Object.create({x: 1, y: 2});\r\n  o.z = 3;\r\n  // let {a, ...{b, c}} = o;\r\n  // console.log(`${a}, ${b}, ${c}`);\r\n}\r\n// 上面代码中，变量x是单纯的解构赋值，所以可以读取继承的属性；扩展运算符产生的变量y和z，只能读取对象自身的属性，\r\n// 所以只有变量z可以赋值成功\r\n\r\n/**\r\n * 3.扩展运算符的解构赋值，不能复制继承自原型对象的属性\r\n */\r\n{\r\n  let o1 = {a: 1};\r\n  let o2 = {b: 2};\r\n  o2.__proto__ = o1;\r\n  let o3 = {...o2};\r\n  console.log(o3 === o2);\r\n  console.log(`扩展运算符不会拷贝继承自原型对象的属性: ${JSON.stringify(o3)}`) // { b: 2 }\r\n}\r\n\r\n{\r\n  const o = Object.create({ x: 1, y: 2 });\r\n  o.z = 3;\r\n  let o2 = {...o, m: 4, n: 5};\r\n  console.log(`o2 = ${JSON.stringify(o2)}`)\r\n}\r\n\r\n{\r\n  var [x1 = 1, y1 = x1] = [];\r\n  var [x2 = 1, y2 = x2] = [2];\r\n  var [x3 = 1, y3 = x3] = [1,2];\r\n  var [x4 = y4, y4 = 1] = [];\r\n  console.log(x1,y1);//1 1\r\n  console.log(x2,y2);//2 2\r\n  console.log(x3,y3);//1 2\r\n  console.log(x4,y4);\r\n}\r\n\r\n/**\r\n * 2.扩展运算符\r\n * 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。\r\n * 如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。\r\n */\r\n// 扩展运算符可以用于合并两个对象。\r\n{\r\n  let o1 = {a: 1};\r\n  let o2 = {b: 2};\r\n  let ab = {...o1, ...o2};\r\n}\r\n// 等同于\r\n// let ab2 = Object.assign({}, o1, o2);\r\n\r\n{\r\n  let obj = {};\r\n  let aWithOverrides = {...obj, x: 1, y: 2};\r\n}\r\n// 等同于\r\n// let aWithOverrides2 = {...a, ...{x: 1, y: 2}};\r\n// 等同于\r\n// let x2 = 1, y2 = 2, aWithOverrides3 = {...a, x, y};\r\n// 等同于\r\n// let aWithOverrides4 = Object.assign({}, a, {x: 1, y: 2});\r\n// 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。\r\n\r\n{\r\n\r\n  let previousVersion = {};\r\n  let newVersion = {\r\n    ...previousVersion,\r\n    name: 'New Name' // Override the name property\r\n  };\r\n}\r\n\r\n// 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。\r\n// 并不会抛出错误，因为x属性只是被定义，但没执行\r\n{\r\n  let obj = {}\r\n  let aWithXGetter = {\r\n    ...obj,\r\n    get x() {\r\n      throw new Error('not thrown yet');\r\n    }\r\n  };\r\n}\r\n\r\n// 会抛出错误，因为x属性被执行了\r\n// {\r\n//   let obj = {};\r\n//   let runtimeError = {\r\n//     ...obj,\r\n//     ...{\r\n//       get x() {\r\n//         throw new Error('thrown now');\r\n//       }\r\n//     }\r\n//   };\r\n// }\r\n\r\n{\r\n  let emptyObject = {...null, ...undefined}; // 不报错\r\n  let obj = {...undefined, ...{a: 1}}\r\n  console.log('undefined: ', obj)\r\n}\r\n"]}