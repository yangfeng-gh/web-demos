{"version":3,"sources":["Destructuring2.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;0CAWU,I;;eAJM,kBAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,C;;QAAX,C;QAAG,C;QAAG,C;;AACX,YAAQ,GAAR,CAAY,CAAZ,E,CAAgB;;AAEhB;AACA,aAAU,IAAV;AAAA;;AAAA;AAAA;AAAA;AAAA;AACQ,yBADR,GACY,CADZ;AAEQ,yBAFR,GAEY,CAFZ;;AAAA;AAAA,6BAGW,IAHX;AAAA;AAAA;AAAA;;AAAA;AAAA,+BAIc,CAJd;;AAAA;AAAA,gCAKiB,CAAC,CAAD,EAAI,IAAI,CAAR,CALjB;AAKS,yBALT;AAKY,yBALZ;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;gBASmD,M;;QAA9C,K;QAAO,M;QAAQ,K;QAAO,M;QAAQ,K;QAAO,K;;AAC1C,YAAQ,GAAR,CAAY,KAAZ,E,CAAoB","file":"Destructuring2.js","sourcesContent":["// 解构赋值不仅适用于var命令，也适用于let和const命令。\r\n\r\n// var [v1, v2, ..., vN ] = array;\r\n// let [v1, v2, ..., vN ] = array;\r\n// const [v1, v2, ..., vN ] = array;\r\n\r\n// 对于Set结构，也可以使用数组的解构赋值。\r\nlet [x, y, z] = new Set([\"a\", \"b\", \"c\"]);\r\nconsole.log(x); // \"a\"\r\n\r\n// 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。\r\nfunction* fibs() {\r\n    var a = 0;\r\n    var b = 1;\r\n    while (true) {\r\n        yield a;\r\n        [a, b] = [b, a + b];\r\n    }\r\n}\r\n\r\nvar [first, second, third, fourth, fifth, sixth] = fibs();\r\nconsole.log(sixth); // 5"]}