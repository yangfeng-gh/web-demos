{"version":3,"sources":["Destructuring.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;MAKK,G,GAAsB,C;MAAf,G,GAAoB,C;MAAd,G,GAAkB,C;aAKjB,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,C;MAAT,K;cAGK,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,C;MAAV,C;MAAK,C;MAIL,I,GAAkB,C;MAAT,I,IAAY,C,EAAG,C,EAAG,C;;cAIb,CAAC,GAAD,C;MAAd,C;MAAG,C;MAAM,C;;cAMD,E;MAAR,I;cACc,CAAC,CAAD,C;MAAd,I;MAAM,I;;AACX,UAAQ,GAAR,CAAY,IAAZ;;AAEA;AACA;cACe,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,C;MAAV,E;MAAI,E;MAIJ,E,GAAiB,C;cAAG,CAAC,CAAD,EAAI,CAAJ,C;MAAf,E;MAAK,E,GAAkB,C","file":"Destructuring.js","sourcesContent":["/**\r\n * Created by yvan on 2016-06-29.\r\n */\r\n\r\n// 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\r\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\r\n// foo // 1\r\n// bar // 2\r\n// baz // 3\r\n\r\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\r\n// third // \"baz\"\r\n\r\nlet [x, , y] = [1, 2, 3];\r\n// x // 1\r\n// y // 3\r\n\r\nlet [head, ...tail] = [1, 2, 3, 4];\r\n// head // 1\r\n// tail // [2, 3, 4]\r\n\r\nlet [a, b, ...c] = ['a'];\r\n// x // \"a\"\r\n// y // undefined\r\n// z // []\r\n\r\n// 如果解构不成功，变量的值就等于undefined。\r\nvar [foo2] = [];\r\nvar [bar2, foo2] = [1];\r\nconsole.log(foo2);\r\n\r\n// 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。\r\n// 这种情况下，解构依然可以成功。\r\nlet [x2, y2] = [1, 2, 3];\r\n// x // 1\r\n// y // 2\r\n\r\nlet [a2, [b2], d2] = [1, [2, 3], 4];\r\n// a // 1\r\n// b // 2\r\n// d // 4\r\n\r\n"]}