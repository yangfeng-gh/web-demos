{"version":3,"sources":["用途.es6"],"names":[],"mappings":";;0HAsGkD,Y;;6JAAA,Y;;;;;;;;;;;;;;;;;;;;;;;eA/FzC,CAAC,CAAD,EAAI,CAAJ,C;AAAR,K;AAAG,K;;AACJ;;AAEA;;AAEA;;AAEA;;AAEA,aAAS,OAAT,GAAmB;AACf,eAAO,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAP;AACH;;mBACe,S;;QAAX,C;QAAG,C;QAAG,C;;AAEX;;AAEA,aAAS,OAAT,GAAmB;AACf,eAAO;AACH,iBAAK,CADF;AAEH,iBAAK;AAFF,SAAP;AAIH;;oBACkB,S;QAAb,G,aAAA,G;QAAK,G,aAAA,G;;AACX;;AAEA;;AAEA;AACA,aAAS,CAAT,QAAsB,CAAE;;AAAF;AAAA,YAAV,CAAU;AAAA,YAAP,CAAO;AAAA,YAAJ,CAAI;AAAW;AACjC,MAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAF;;AAEA;AACA,aAAS,CAAT,QAAsB,CAAE;AAAF,YAAV,CAAU,SAAV,CAAU;AAAA,YAAP,CAAO,SAAP,CAAO;AAAA,YAAJ,CAAI,SAAJ,CAAI;AAAW;AACjC,MAAE,EAAC,GAAG,CAAJ,EAAO,GAAG,CAAV,EAAa,GAAG,CAAhB,EAAF;AACA;;AAEA;;AAEA,QAAI,WAAW;AACX,YAAI,EADO;AAEX,gBAAQ,IAFG;AAGX,cAAM,CAAC,GAAD,EAAM,IAAN;AAHK,KAAf;;QAMM,E,GAA6B,Q,CAA7B,E;QAAI,M,GAAyB,Q,CAAzB,M;QAAc,M,GAAW,Q,CAAjB,I;;;AAElB,YAAQ,GAAR,CAAY,EAAZ,EAAgB,MAAhB,EAAwB,MAAxB;AACA;AACA;;AAEA;;;AAGA,WAAO,IAAP,GAAc,UAAU,GAAV,SAQX;AACC;;AADD,gCAPC,KAOD;AAAA,YAPC,KAOD,+BAPS,IAOT;AAAA,qCANC,UAMD;AAAA,YANC,UAMD,oCANc,YAAY,CAAE,CAM5B;AAAA,gCALC,KAKD;AAAA,YALC,KAKD,+BALS,IAKT;AAAA,mCAJC,QAID;AAAA,YAJC,QAID,kCAJY,YAAY,CAAE,CAI1B;AAAA,sCAHC,WAGD;AAAA,YAHC,WAGD,qCAHe,KAGf;AAAA,iCAFC,MAED;AAAA,YAFC,MAED,gCAFU,IAEV;AAEF,KAVD;AAWA;;AAEA;;AAEA;;AAEA,QAAI,MAAM,mBAAV;AACA,QAAI,GAAJ,CAAQ,OAAR,EAAiB,OAAjB;AACA,QAAI,GAAJ,CAAQ,QAAR,EAAkB,OAAlB;;;;;;;AAEA,wDAAyB,GAAzB,4GAA8B;AAAA;;AAAA;;AAAA,gBAApB,GAAoB;AAAA,gBAAf,KAAe;;AAC1B,oBAAQ,GAAR,CAAY,MAAM,MAAN,GAAe,KAA3B;AACH;AACD;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AACA,yDAAkB,GAAlB,iHAAuB;AAAA;;AAAA;;AAAA,gBAAb,IAAa;AAEtB;AADG;;;AAGJ;;;;;;;;;;;;;;;;;;;;;AACA,yDAAqB,GAArB,iHAA0B;AAAA;;AAAA;;AAAA,gBAAf,MAAe;AAEzB;AADG;;AAEJ;;AAEA;;;;;;;;;;;;;;;;;QAGQ,iB,YAAA,iB;QAAmB,U,YAAA,U","file":"用途.js","sourcesContent":["/**\r\n * Created by yvan on 2016-06-30.\r\n */\r\n// 变量的解构赋值用途很多。\r\n\r\n// （1）交换变量的值\r\n\r\n[x, y] = [y, x];\r\n// 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。\r\n\r\n// （2）从函数返回多个值\r\n\r\n// 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\r\n\r\n// 返回一个数组\r\n\r\nfunction example() {\r\n    return [1, 2, 3];\r\n}\r\nvar [a, b, c] = example();\r\n\r\n// 返回一个对象\r\n\r\nfunction example() {\r\n    return {\r\n        foo: 1,\r\n        bar: 2\r\n    };\r\n}\r\nvar { foo, bar } = example();\r\n// （3）函数参数的定义\r\n\r\n// 解构赋值可以方便地将一组参数与变量名对应起来。\r\n\r\n// 参数是一组有次序的值\r\nfunction f([x, y, z]) { /*...*/ }\r\nf([1, 2, 3]);\r\n\r\n// 参数是一组无次序的值\r\nfunction f({x, y, z}) { /*...*/ }\r\nf({z: 3, y: 2, x: 1});\r\n// （4）提取JSON数据\r\n\r\n// 解构赋值对提取JSON对象中的数据，尤其有用。\r\n\r\nvar jsonData = {\r\n    id: 42,\r\n    status: \"OK\",\r\n    data: [867, 5309]\r\n};\r\n\r\nlet { id, status, data: number } = jsonData;\r\n\r\nconsole.log(id, status, number);\r\n// 42, \"OK\", [867, 5309]\r\n// 上面代码可以快速提取JSON数据的值。\r\n\r\n// （5）函数参数的默认值\r\n\r\n\r\njQuery.ajax = function (url, {\r\n    async = true,\r\n    beforeSend = function () {},\r\n    cache = true,\r\n    complete = function () {},\r\n    crossDomain = false,\r\n    global = true,\r\n    // ... more config\r\n}) {\r\n    // ... do stuff\r\n};\r\n// 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\r\n\r\n// （6）遍历Map结构\r\n\r\n// 任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。\r\n\r\nvar map = new Map();\r\nmap.set('first', 'hello');\r\nmap.set('second', 'world');\r\n\r\nfor (let [key, value] of map) {\r\n    console.log(key + \" is \" + value);\r\n}\r\n// first is hello\r\n// second is world\r\n// 如果只想获取键名，或者只想获取键值，可以写成下面这样。\r\n\r\n// 获取键名\r\nfor (let [key] of map) {\r\n    // ...\r\n}\r\n\r\n// 获取键值\r\nfor (let [,value] of map) {\r\n    // ...\r\n}\r\n// （7）输入模块的指定方法\r\n\r\n// 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\r\n\r\n\r\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");"]}