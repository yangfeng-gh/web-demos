{"version":3,"sources":["Generator函数与Promise的结合.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAGA,aAAS,MAAT,GAAmB;AACf,eAAO,sBAAY,UAAU,OAAV,EAAmB,MAAnB,EAA0B;AACzC,oBAAQ,KAAR;AACH,SAFM,CAAP;AAGH;;AAED,QAAI,+BAAI,SAAJ,CAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAEgB,QAFhB;;AAAA;AAEI,2BAFJ;;AAGA,gCAAQ,GAAR,CAAY,GAAZ;AAHA;AAAA;;AAAA;AAAA;AAAA;;AAKA,gCAAQ,GAAR;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAJ,CAAI;AAAA,KAAJ,CAAJ;;AASA,aAAS,GAAT,CAAc,SAAd,EAAyB;AACrB,YAAI,KAAK,WAAT;;AAEA,iBAAS,EAAT,CAAY,MAAZ,EAAoB;AAChB,gBAAI,OAAO,IAAX,EAAiB,OAAO,OAAO,KAAd;;AAEjB,mBAAO,OAAO,KAAP,CAAa,IAAb,CAAkB,UAAU,KAAV,EAAiB;AACtC,uBAAO,GAAG,GAAG,IAAH,CAAQ,KAAR,CAAH,CAAP;AACH,aAFM,EAEJ,UAAU,KAAV,EAAiB;AAChB,uBAAO,GAAG,GAAG,KAAH,CAAS,KAAT,CAAH,CAAP;AACH,aAJM,CAAP;AAKH;;AAED,WAAG,GAAG,IAAH,EAAH;AACH;;AAED,QAAI,CAAJ;;AAEA;AACA","file":"Generator函数与Promise的结合.js","sourcesContent":["/**\r\n * 使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。\r\n */\r\nfunction getFoo () {\r\n    return new Promise(function (resolve, reject){\r\n        resolve('foo');\r\n    });\r\n}\r\n\r\nvar g = function* () {\r\n    try {\r\n        var foo = yield getFoo();\r\n        console.log(foo);\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n};\r\n\r\nfunction run (generator) {\r\n    var it = generator();\r\n\r\n    function go(result) {\r\n        if (result.done) return result.value;\r\n\r\n        return result.value.then(function (value) {\r\n            return go(it.next(value));\r\n        }, function (error) {\r\n            return go(it.throw(error));\r\n        });\r\n    }\r\n\r\n    go(it.next());\r\n}\r\n\r\nrun(g);\r\n\r\n// 上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。\r\n// 函数run用来处理这个Promise对象，并调用下一个next方法。"]}