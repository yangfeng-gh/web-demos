{"version":3,"sources":["Promise.prototype.finally.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAKA,sBAAQ,SAAR,CAAkB,OAAlB,GAA4B,UAAU,QAAV,EAAoB;AAC5C,YAAI,IAAI,KAAK,WAAb;AACA,eAAO,KAAK,IAAL,CACH;AAAA,mBAAS,EAAE,OAAF,CAAU,UAAV,EAAsB,IAAtB,CAA2B;AAAA,uBAAM,KAAN;AAAA,aAA3B,CAAT;AAAA,SADG,EAEH;AAAA,mBAAU,EAAE,OAAF,CAAU,UAAV,EAAsB,IAAtB,CAA2B,YAAM;AACvC,sBAAM,MAAN;AACH,aAFS,CAAV;AAAA,SAFG,CAAP;AAMH,KARD;AASA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAQ,OAAR,GAAkB,IAAlB,CAAuB,YAAK;AACxB,cAAM,IAAI,KAAJ,CAAU,cAAV,CAAN;AACH,KAFD,EAEG,OAFH,CAEW,QAFX;;AAIA,aAAS,QAAT,GAAoB;AAChB,gBAAQ,GAAR,CAAY,cAAZ;AACH","file":"Promise.prototype.finally.js","sourcesContent":["/**\r\n * finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。\r\n * 它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\r\n */\r\n\r\nPromise.prototype.finally = function (callback) {\r\n    let P = this.constructor;\r\n    return this.then(\r\n        value => P.resolve(callback()).then(() => value),\r\n        reason => P.resolve(callback()).then(() => {\r\n            throw reason;\r\n        })\r\n    );\r\n};\r\n// 服务器使用Promise处理请求，然后使用finally方法关掉服务器。\r\n// server.listen(0).then(function () {\r\n//     // run test\r\n// }).finally(server.stop);\r\n\r\n// 上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。\r\n\r\nPromise.resolve().then(()=> {\r\n    throw new Error('finally test');\r\n}).finally(callback);\r\n\r\nfunction callback() {\r\n    console.log('finally test');\r\n}"]}