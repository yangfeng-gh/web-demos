{"version":3,"sources":["Promise.prototype.done.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;AAMA,sBAAQ,SAAR,CAAkB,IAAlB,GAAyB,UAAU,WAAV,EAAuB,UAAvB,EAAmC;AACxD,aAAK,IAAL,CAAU,WAAV,EAAuB,UAAvB,EAAmC,KAAnC,CAAyC,UAAU,MAAV,EAAkB;AACvD;AACA,uBAAW,YAAM;AACb,sBAAM,MAAN;AACH,aAFD,EAEG,CAFH;AAGH,SALD;AAMH,KAPD;AAQA;AACA,sBAAQ,OAAR,CAAgB,UAAhB,EAA4B,IAA5B,CAAiC,UAAU,GAAV,EAAe;AAC5C,eAAO,GAAP;AACH,KAFD,EAEG,IAFH,CAEQ,UAAS,GAAT,EAAa;AACjB,gBAAQ,GAAR,CAAY,GAAZ;AACA,cAAM,IAAI,KAAJ,CAAU,KAAV,CAAN;AACH,KALD,EAKG,IALH;;AAOA;AACA","file":"Promise.prototype.done.js","sourcesContent":["/**\r\n * Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，\r\n * 都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。\r\n * 因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\r\n */\r\n\r\nPromise.prototype.done = function (onFulfilled, onRejected) {\r\n    this.then(onFulfilled, onRejected).catch(function (reason) {\r\n        // 抛出一个全局错误\r\n        setTimeout(() => {\r\n            throw reason\r\n        }, 0);\r\n    });\r\n};\r\n// 调用done方法\r\nPromise.resolve('ayncFunc').then(function (val) {\r\n    return val;\r\n}).then(function(val){\r\n    console.log(val);\r\n    throw new Error('出错了');\r\n}).done();\r\n\r\n// 从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。\r\n// 但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。"]}