{"version":3,"sources":["Promise.prototype.catch.es6"],"names":[],"mappings":"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","file":"Promise.prototype.catch.js","sourcesContent":["/**\r\n * Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\r\n * 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。\r\n * catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。\r\n */\r\n\r\nvar promise = new Promise(function (resolve, reject) {\r\n    throw new Error('test');\r\n});\r\npromise.catch(function (error) {\r\n    console.log(error);\r\n});\r\n// Error: test\r\n\r\n// 等价于\r\n// 写法一\r\nvar promise = new Promise(function (resolve, reject) {\r\n    try {\r\n        throw new Error('写法一');\r\n    } catch (e) {\r\n        reject(e);\r\n    }\r\n});\r\npromise.catch(function (error) {\r\n    console.log(error);\r\n});\r\n\r\n\r\n// 写法二\r\nvar promise = new Promise(function (resolve, reject) {\r\n    reject(new Error('写法二'));\r\n});\r\npromise.catch(function (error) {\r\n    console.log(error);\r\n});\r\n\r\n// 如果Promise状态已经变成Resolved，再抛出错误是无效的。\r\nvar promise = new Promise(function (resolve, reject) {\r\n    resolve('ok');\r\n    throw new Error('如果Promise状态已经变成Resolved，再抛出错误是无效的');\r\n});\r\npromise.then(function (value) {\r\n    console.log(value)\r\n}).catch(function (error) {\r\n    console.log(error)\r\n});\r\n\r\nvar someAsyncThing = function() {\r\n    return new Promise(function(resolve, reject) {\r\n        // 下面一行会报错，因为x没有声明\r\n        resolve(x + 2);\r\n    });\r\n};\r\n\r\nsomeAsyncThing().then(function() {\r\n    console.log('everything is great');\r\n});\r\n// 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。\r\n// Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。\r\n\r\nvar promise = new Promise(function(resolve, reject) {\r\n    resolve(\"ok\");\r\n    setTimeout(function() { throw new Error('test') }, 0)\r\n});\r\npromise.then(function(value) { console.log(value) });\r\n// ok\r\n// Uncaught Error: test\r\n\r\n// 上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try...catch语句，就冒泡到最外层，成了未捕获的错误。\r\n// 因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。\r\n\r\n// Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误\r\nprocess.on('unhandledRejection', function (err, p) {\r\n    console.error(err.stack)\r\n});\r\n// 第一个是错误对象，第二个是报错的Promise实例\r\n\r\nvar someAsyncThing = function() {\r\n    return new Promise(function(resolve, reject) {\r\n        // 下面一行会报错，因为x没有声明\r\n        resolve(x + 2);\r\n    });\r\n};\r\n\r\nsomeAsyncThing()\r\n    .catch(function(error) {\r\n        console.log('oh no', error);\r\n    })\r\n    .then(function() {\r\n        console.log('carry on');\r\n    });\r\n// oh no [ReferenceError: x is not defined]\r\n// carry on\r\n// 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。\r\n\r\nsomeAsyncThing().then(function() {\r\n    return someOtherAsyncThing();\r\n}).catch(function(error) {\r\n    console.log('oh no', error);\r\n    // 下面一行会报错，因为y没有声明\r\n    y + 2;\r\n}).catch(function(error) {\r\n    console.log('carry on', error);\r\n});\r\n// oh no [ReferenceError: x is not defined]\r\n// carry on [ReferenceError: y is not defined]\r\n// 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。"]}